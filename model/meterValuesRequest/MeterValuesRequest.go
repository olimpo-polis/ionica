// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package meterValuesRequest

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId" mapstructure:"vendorId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["vendorId"]; raw != nil && !ok {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.VendorId) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "vendorId", 255)
	}
	*j = CustomDataType(plain)
	return nil
}

type LocationEnumType string

const LocationEnumTypeBody LocationEnumType = "Body"
const LocationEnumTypeCable LocationEnumType = "Cable"
const LocationEnumTypeEV LocationEnumType = "EV"
const LocationEnumTypeInlet LocationEnumType = "Inlet"
const LocationEnumTypeOutlet LocationEnumType = "Outlet"

var enumValues_LocationEnumType = []interface{}{
	"Body",
	"Cable",
	"EV",
	"Inlet",
	"Outlet",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocationEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LocationEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LocationEnumType, v)
	}
	*j = LocationEnumType(v)
	return nil
}

type MeasurandEnumType string

const MeasurandEnumTypeCurrentExport MeasurandEnumType = "Current.Export"
const MeasurandEnumTypeCurrentImport MeasurandEnumType = "Current.Import"
const MeasurandEnumTypeCurrentOffered MeasurandEnumType = "Current.Offered"
const MeasurandEnumTypeEnergyActiveExportInterval MeasurandEnumType = "Energy.Active.Export.Interval"
const MeasurandEnumTypeEnergyActiveExportRegister MeasurandEnumType = "Energy.Active.Export.Register"
const MeasurandEnumTypeEnergyActiveImportInterval MeasurandEnumType = "Energy.Active.Import.Interval"
const MeasurandEnumTypeEnergyActiveImportRegister MeasurandEnumType = "Energy.Active.Import.Register"
const MeasurandEnumTypeEnergyActiveNet MeasurandEnumType = "Energy.Active.Net"
const MeasurandEnumTypeEnergyApparentExport MeasurandEnumType = "Energy.Apparent.Export"
const MeasurandEnumTypeEnergyApparentImport MeasurandEnumType = "Energy.Apparent.Import"
const MeasurandEnumTypeEnergyApparentNet MeasurandEnumType = "Energy.Apparent.Net"
const MeasurandEnumTypeEnergyReactiveExportInterval MeasurandEnumType = "Energy.Reactive.Export.Interval"
const MeasurandEnumTypeEnergyReactiveExportRegister MeasurandEnumType = "Energy.Reactive.Export.Register"
const MeasurandEnumTypeEnergyReactiveImportInterval MeasurandEnumType = "Energy.Reactive.Import.Interval"
const MeasurandEnumTypeEnergyReactiveImportRegister MeasurandEnumType = "Energy.Reactive.Import.Register"
const MeasurandEnumTypeEnergyReactiveNet MeasurandEnumType = "Energy.Reactive.Net"
const MeasurandEnumTypeFrequency MeasurandEnumType = "Frequency"
const MeasurandEnumTypePowerActiveExport MeasurandEnumType = "Power.Active.Export"
const MeasurandEnumTypePowerActiveImport MeasurandEnumType = "Power.Active.Import"
const MeasurandEnumTypePowerFactor MeasurandEnumType = "Power.Factor"
const MeasurandEnumTypePowerOffered MeasurandEnumType = "Power.Offered"
const MeasurandEnumTypePowerReactiveExport MeasurandEnumType = "Power.Reactive.Export"
const MeasurandEnumTypePowerReactiveImport MeasurandEnumType = "Power.Reactive.Import"
const MeasurandEnumTypeSoC MeasurandEnumType = "SoC"
const MeasurandEnumTypeVoltage MeasurandEnumType = "Voltage"

var enumValues_MeasurandEnumType = []interface{}{
	"Current.Export",
	"Current.Import",
	"Current.Offered",
	"Energy.Active.Export.Register",
	"Energy.Active.Import.Register",
	"Energy.Reactive.Export.Register",
	"Energy.Reactive.Import.Register",
	"Energy.Active.Export.Interval",
	"Energy.Active.Import.Interval",
	"Energy.Active.Net",
	"Energy.Reactive.Export.Interval",
	"Energy.Reactive.Import.Interval",
	"Energy.Reactive.Net",
	"Energy.Apparent.Net",
	"Energy.Apparent.Import",
	"Energy.Apparent.Export",
	"Frequency",
	"Power.Active.Export",
	"Power.Active.Import",
	"Power.Factor",
	"Power.Offered",
	"Power.Reactive.Export",
	"Power.Reactive.Import",
	"SoC",
	"Voltage",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasurandEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MeasurandEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MeasurandEnumType, v)
	}
	*j = MeasurandEnumType(v)
	return nil
}

// Meter_ Value
// urn:x-oca:ocpp:uid:2:233265
// Collection of one or more sampled values in MeterValuesRequest and
// TransactionEvent. All sampled values in a MeterValue are sampled at the same
// point in time.
type MeterValueType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// SampledValue corresponds to the JSON schema field "sampledValue".
	SampledValue []SampledValueType `json:"sampledValue" yaml:"sampledValue" mapstructure:"sampledValue"`

	// Meter_ Value. Timestamp. Date_ Time
	// urn:x-oca:ocpp:uid:1:569259
	// Timestamp for measured value(s).
	//
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeterValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sampledValue"]; raw != nil && !ok {
		return fmt.Errorf("field sampledValue in MeterValueType: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in MeterValueType: required")
	}
	type Plain MeterValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SampledValue != nil && len(plain.SampledValue) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "sampledValue", 1)
	}
	*j = MeterValueType(plain)
	return nil
}

// Request_ Body
// urn:x-enexis:ecdm:uid:2:234744
type MeterValuesRequestJson struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Request_ Body. EVSEID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:571101
	// This contains a number (&gt;0) designating an EVSE of the Charging Station. ‘0’
	// (zero) is used to designate the main power meter.
	//
	EvseId int `json:"evseId" yaml:"evseId" mapstructure:"evseId"`

	// MeterValue corresponds to the JSON schema field "meterValue".
	MeterValue []MeterValueType `json:"meterValue" yaml:"meterValue" mapstructure:"meterValue"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeterValuesRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["evseId"]; raw != nil && !ok {
		return fmt.Errorf("field evseId in MeterValuesRequestJson: required")
	}
	if _, ok := raw["meterValue"]; raw != nil && !ok {
		return fmt.Errorf("field meterValue in MeterValuesRequestJson: required")
	}
	type Plain MeterValuesRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MeterValue != nil && len(plain.MeterValue) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "meterValue", 1)
	}
	*j = MeterValuesRequestJson(plain)
	return nil
}

type PhaseEnumType string

const PhaseEnumTypeL1 PhaseEnumType = "L1"
const PhaseEnumTypeL1L2 PhaseEnumType = "L1-L2"
const PhaseEnumTypeL1N PhaseEnumType = "L1-N"
const PhaseEnumTypeL2 PhaseEnumType = "L2"
const PhaseEnumTypeL2L3 PhaseEnumType = "L2-L3"
const PhaseEnumTypeL2N PhaseEnumType = "L2-N"
const PhaseEnumTypeL3 PhaseEnumType = "L3"
const PhaseEnumTypeL3L1 PhaseEnumType = "L3-L1"
const PhaseEnumTypeL3N PhaseEnumType = "L3-N"
const PhaseEnumTypeN PhaseEnumType = "N"

var enumValues_PhaseEnumType = []interface{}{
	"L1",
	"L2",
	"L3",
	"N",
	"L1-N",
	"L2-N",
	"L3-N",
	"L1-L2",
	"L2-L3",
	"L3-L1",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PhaseEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PhaseEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PhaseEnumType, v)
	}
	*j = PhaseEnumType(v)
	return nil
}

type ReadingContextEnumType string

const ReadingContextEnumTypeInterruptionBegin ReadingContextEnumType = "Interruption.Begin"
const ReadingContextEnumTypeInterruptionEnd ReadingContextEnumType = "Interruption.End"
const ReadingContextEnumTypeOther ReadingContextEnumType = "Other"
const ReadingContextEnumTypeSampleClock ReadingContextEnumType = "Sample.Clock"
const ReadingContextEnumTypeSamplePeriodic ReadingContextEnumType = "Sample.Periodic"
const ReadingContextEnumTypeTransactionBegin ReadingContextEnumType = "Transaction.Begin"
const ReadingContextEnumTypeTransactionEnd ReadingContextEnumType = "Transaction.End"
const ReadingContextEnumTypeTrigger ReadingContextEnumType = "Trigger"

var enumValues_ReadingContextEnumType = []interface{}{
	"Interruption.Begin",
	"Interruption.End",
	"Other",
	"Sample.Clock",
	"Sample.Periodic",
	"Transaction.Begin",
	"Transaction.End",
	"Trigger",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadingContextEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReadingContextEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReadingContextEnumType, v)
	}
	*j = ReadingContextEnumType(v)
	return nil
}

// Sampled_ Value
// urn:x-oca:ocpp:uid:2:233266
// Single sampled value in MeterValues. Each value can be accompanied by optional
// fields.
//
// To save on mobile data usage, default values of all of the optional fields are
// such that. The value without any additional fields will be interpreted, as a
// register reading of active import energy in Wh (Watt-hour) units.
type SampledValueType struct {
	// Context corresponds to the JSON schema field "context".
	Context *ReadingContextEnumType `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Location corresponds to the JSON schema field "location".
	Location *LocationEnumType `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Measurand corresponds to the JSON schema field "measurand".
	Measurand *MeasurandEnumType `json:"measurand,omitempty" yaml:"measurand,omitempty" mapstructure:"measurand,omitempty"`

	// Phase corresponds to the JSON schema field "phase".
	Phase *PhaseEnumType `json:"phase,omitempty" yaml:"phase,omitempty" mapstructure:"phase,omitempty"`

	// SignedMeterValue corresponds to the JSON schema field "signedMeterValue".
	SignedMeterValue *SignedMeterValueType `json:"signedMeterValue,omitempty" yaml:"signedMeterValue,omitempty" mapstructure:"signedMeterValue,omitempty"`

	// UnitOfMeasure corresponds to the JSON schema field "unitOfMeasure".
	UnitOfMeasure *UnitOfMeasureType `json:"unitOfMeasure,omitempty" yaml:"unitOfMeasure,omitempty" mapstructure:"unitOfMeasure,omitempty"`

	// Sampled_ Value. Value. Measure
	// urn:x-oca:ocpp:uid:1:569260
	// Indicates the measured value.
	//
	//
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SampledValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in SampledValueType: required")
	}
	type Plain SampledValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SampledValueType(plain)
	return nil
}

// Represent a signed version of the meter value.
type SignedMeterValueType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Method used to encode the meter values before applying the digital signature
	// algorithm.
	//
	EncodingMethod string `json:"encodingMethod" yaml:"encodingMethod" mapstructure:"encodingMethod"`

	// Base64 encoded, sending depends on configuration variable
	// _PublicKeyWithSignedMeterValue_.
	//
	PublicKey string `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// Base64 encoded, contains the signed data which might contain more then just the
	// meter value. It can contain information like timestamps, reference to a
	// customer etc.
	//
	SignedMeterData string `json:"signedMeterData" yaml:"signedMeterData" mapstructure:"signedMeterData"`

	// Method used to create the digital signature.
	//
	SigningMethod string `json:"signingMethod" yaml:"signingMethod" mapstructure:"signingMethod"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedMeterValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["encodingMethod"]; raw != nil && !ok {
		return fmt.Errorf("field encodingMethod in SignedMeterValueType: required")
	}
	if _, ok := raw["publicKey"]; raw != nil && !ok {
		return fmt.Errorf("field publicKey in SignedMeterValueType: required")
	}
	if _, ok := raw["signedMeterData"]; raw != nil && !ok {
		return fmt.Errorf("field signedMeterData in SignedMeterValueType: required")
	}
	if _, ok := raw["signingMethod"]; raw != nil && !ok {
		return fmt.Errorf("field signingMethod in SignedMeterValueType: required")
	}
	type Plain SignedMeterValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.EncodingMethod) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "encodingMethod", 50)
	}
	if len(plain.PublicKey) > 2500 {
		return fmt.Errorf("field %s length: must be <= %d", "publicKey", 2500)
	}
	if len(plain.SignedMeterData) > 2500 {
		return fmt.Errorf("field %s length: must be <= %d", "signedMeterData", 2500)
	}
	if len(plain.SigningMethod) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "signingMethod", 50)
	}
	*j = SignedMeterValueType(plain)
	return nil
}

// Represents a UnitOfMeasure with a multiplier
type UnitOfMeasureType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Multiplier, this value represents the exponent to base 10. I.e. multiplier 3
	// means 10 raised to the 3rd power. Default is 0.
	//
	Multiplier int `json:"multiplier,omitempty" yaml:"multiplier,omitempty" mapstructure:"multiplier,omitempty"`

	// Unit of the value. Default = "Wh" if the (default) measurand is an "Energy"
	// type.
	// This field SHALL use a value from the list Standardized Units of Measurements
	// in Part 2 Appendices.
	// If an applicable unit is available in that list, otherwise a "custom" unit
	// might be used.
	//
	Unit string `json:"unit,omitempty" yaml:"unit,omitempty" mapstructure:"unit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnitOfMeasureType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain UnitOfMeasureType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["multiplier"]; !ok || v == nil {
		plain.Multiplier = 0.0
	}
	if v, ok := raw["unit"]; !ok || v == nil {
		plain.Unit = "Wh"
	}
	if len(plain.Unit) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "unit", 20)
	}
	*j = UnitOfMeasureType(plain)
	return nil
}
