// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package notifyEventRequest

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// A physical or logical component
type ComponentType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Evse corresponds to the JSON schema field "evse".
	Evse *EVSEType `json:"evse,omitempty" yaml:"evse,omitempty" mapstructure:"evse,omitempty"`

	// Name of instance in case the component exists as multiple instances. Case
	// Insensitive. strongly advised to use Camel Case.
	//
	Instance *string `json:"instance,omitempty" yaml:"instance,omitempty" mapstructure:"instance,omitempty"`

	// Name of the component. Name should be taken from the list of standardized
	// component names whenever possible. Case Insensitive. strongly advised to use
	// Camel Case.
	//
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentType: required")
	}
	type Plain ComponentType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Instance != nil && len(*plain.Instance) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "instance", 50)
	}
	if len(plain.Name) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 50)
	}
	*j = ComponentType(plain)
	return nil
}

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId" mapstructure:"vendorId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["vendorId"]; raw != nil && !ok {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.VendorId) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "vendorId", 255)
	}
	*j = CustomDataType(plain)
	return nil
}

// EVSE
// urn:x-oca:ocpp:uid:2:233123
// Electric Vehicle Supply Equipment
type EVSEType struct {
	// An id to designate a specific connector (on an EVSE) by connector index number.
	//
	ConnectorId *int `json:"connectorId,omitempty" yaml:"connectorId,omitempty" mapstructure:"connectorId,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Identified_ Object. MRID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:569198
	// EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the
	// Charging Station.
	//
	Id int `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EVSEType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in EVSEType: required")
	}
	type Plain EVSEType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EVSEType(plain)
	return nil
}

// Class to report an event notification for a component-variable.
type EventDataType struct {
	// Actual value (_attributeType_ Actual) of the variable.
	//
	// The Configuration Variable
	// &lt;&lt;configkey-reporting-value-size,ReportingValueSize&gt;&gt; can be used
	// to limit GetVariableResult.attributeValue, VariableAttribute.value and
	// EventData.actualValue. The max size of these values will always remain equal.
	//
	//
	ActualValue string `json:"actualValue" yaml:"actualValue" mapstructure:"actualValue"`

	// Refers to the Id of an event that is considered to be the cause for this event.
	//
	//
	Cause *int `json:"cause,omitempty" yaml:"cause,omitempty" mapstructure:"cause,omitempty"`

	// _Cleared_ is set to true to report the clearing of a monitored situation, i.e.
	// a 'return to normal'.
	//
	//
	Cleared *bool `json:"cleared,omitempty" yaml:"cleared,omitempty" mapstructure:"cleared,omitempty"`

	// Component corresponds to the JSON schema field "component".
	Component ComponentType `json:"component" yaml:"component" mapstructure:"component"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Identifies the event. This field can be referred to as a cause by other events.
	//
	//
	EventId int `json:"eventId" yaml:"eventId" mapstructure:"eventId"`

	// EventNotificationType corresponds to the JSON schema field
	// "eventNotificationType".
	EventNotificationType EventNotificationEnumType `json:"eventNotificationType" yaml:"eventNotificationType" mapstructure:"eventNotificationType"`

	// Technical (error) code as reported by component.
	//
	TechCode *string `json:"techCode,omitempty" yaml:"techCode,omitempty" mapstructure:"techCode,omitempty"`

	// Technical detail information as reported by component.
	//
	TechInfo *string `json:"techInfo,omitempty" yaml:"techInfo,omitempty" mapstructure:"techInfo,omitempty"`

	// Timestamp of the moment the report was generated.
	//
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// If an event notification is linked to a specific transaction, this field can be
	// used to specify its transactionId.
	//
	TransactionId *string `json:"transactionId,omitempty" yaml:"transactionId,omitempty" mapstructure:"transactionId,omitempty"`

	// Trigger corresponds to the JSON schema field "trigger".
	Trigger EventTriggerEnumType `json:"trigger" yaml:"trigger" mapstructure:"trigger"`

	// Variable corresponds to the JSON schema field "variable".
	Variable VariableType `json:"variable" yaml:"variable" mapstructure:"variable"`

	// Identifies the VariableMonitoring which triggered the event.
	//
	VariableMonitoringId *int `json:"variableMonitoringId,omitempty" yaml:"variableMonitoringId,omitempty" mapstructure:"variableMonitoringId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["actualValue"]; raw != nil && !ok {
		return fmt.Errorf("field actualValue in EventDataType: required")
	}
	if _, ok := raw["component"]; raw != nil && !ok {
		return fmt.Errorf("field component in EventDataType: required")
	}
	if _, ok := raw["eventId"]; raw != nil && !ok {
		return fmt.Errorf("field eventId in EventDataType: required")
	}
	if _, ok := raw["eventNotificationType"]; raw != nil && !ok {
		return fmt.Errorf("field eventNotificationType in EventDataType: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in EventDataType: required")
	}
	if _, ok := raw["trigger"]; raw != nil && !ok {
		return fmt.Errorf("field trigger in EventDataType: required")
	}
	if _, ok := raw["variable"]; raw != nil && !ok {
		return fmt.Errorf("field variable in EventDataType: required")
	}
	type Plain EventDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.ActualValue) > 2500 {
		return fmt.Errorf("field %s length: must be <= %d", "actualValue", 2500)
	}
	if plain.TechCode != nil && len(*plain.TechCode) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "techCode", 50)
	}
	if plain.TechInfo != nil && len(*plain.TechInfo) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "techInfo", 500)
	}
	if plain.TransactionId != nil && len(*plain.TransactionId) > 36 {
		return fmt.Errorf("field %s length: must be <= %d", "transactionId", 36)
	}
	*j = EventDataType(plain)
	return nil
}

type EventNotificationEnumType string

const EventNotificationEnumTypeCustomMonitor EventNotificationEnumType = "CustomMonitor"
const EventNotificationEnumTypeHardWiredMonitor EventNotificationEnumType = "HardWiredMonitor"
const EventNotificationEnumTypeHardWiredNotification EventNotificationEnumType = "HardWiredNotification"
const EventNotificationEnumTypePreconfiguredMonitor EventNotificationEnumType = "PreconfiguredMonitor"

var enumValues_EventNotificationEnumType = []interface{}{
	"HardWiredNotification",
	"HardWiredMonitor",
	"PreconfiguredMonitor",
	"CustomMonitor",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventNotificationEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventNotificationEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventNotificationEnumType, v)
	}
	*j = EventNotificationEnumType(v)
	return nil
}

type EventTriggerEnumType string

const EventTriggerEnumTypeAlerting EventTriggerEnumType = "Alerting"
const EventTriggerEnumTypeDelta EventTriggerEnumType = "Delta"
const EventTriggerEnumTypePeriodic EventTriggerEnumType = "Periodic"

var enumValues_EventTriggerEnumType = []interface{}{
	"Alerting",
	"Delta",
	"Periodic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventTriggerEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventTriggerEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventTriggerEnumType, v)
	}
	*j = EventTriggerEnumType(v)
	return nil
}

type NotifyEventRequestJson struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// EventData corresponds to the JSON schema field "eventData".
	EventData []EventDataType `json:"eventData" yaml:"eventData" mapstructure:"eventData"`

	// Timestamp of the moment this message was generated at the Charging Station.
	//
	GeneratedAt time.Time `json:"generatedAt" yaml:"generatedAt" mapstructure:"generatedAt"`

	// Sequence number of this message. First message starts at 0.
	//
	SeqNo int `json:"seqNo" yaml:"seqNo" mapstructure:"seqNo"`

	// “to be continued” indicator. Indicates whether another part of the report
	// follows in an upcoming notifyEventRequest message. Default value when omitted
	// is false.
	//
	Tbc bool `json:"tbc,omitempty" yaml:"tbc,omitempty" mapstructure:"tbc,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotifyEventRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["eventData"]; raw != nil && !ok {
		return fmt.Errorf("field eventData in NotifyEventRequestJson: required")
	}
	if _, ok := raw["generatedAt"]; raw != nil && !ok {
		return fmt.Errorf("field generatedAt in NotifyEventRequestJson: required")
	}
	if _, ok := raw["seqNo"]; raw != nil && !ok {
		return fmt.Errorf("field seqNo in NotifyEventRequestJson: required")
	}
	type Plain NotifyEventRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.EventData != nil && len(plain.EventData) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "eventData", 1)
	}
	if v, ok := raw["tbc"]; !ok || v == nil {
		plain.Tbc = false
	}
	*j = NotifyEventRequestJson(plain)
	return nil
}

// Reference key to a component-variable.
type VariableType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Name of instance in case the variable exists as multiple instances. Case
	// Insensitive. strongly advised to use Camel Case.
	//
	Instance *string `json:"instance,omitempty" yaml:"instance,omitempty" mapstructure:"instance,omitempty"`

	// Name of the variable. Name should be taken from the list of standardized
	// variable names whenever possible. Case Insensitive. strongly advised to use
	// Camel Case.
	//
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VariableType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in VariableType: required")
	}
	type Plain VariableType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Instance != nil && len(*plain.Instance) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "instance", 50)
	}
	if len(plain.Name) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 50)
	}
	*j = VariableType(plain)
	return nil
}
