// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package setNetworkProfileRequest

import "encoding/json"
import "fmt"
import "reflect"

type APNAuthenticationEnumType string

const APNAuthenticationEnumTypeAUTO APNAuthenticationEnumType = "AUTO"
const APNAuthenticationEnumTypeCHAP APNAuthenticationEnumType = "CHAP"
const APNAuthenticationEnumTypeNONE APNAuthenticationEnumType = "NONE"
const APNAuthenticationEnumTypePAP APNAuthenticationEnumType = "PAP"

var enumValues_APNAuthenticationEnumType = []interface{}{
	"CHAP",
	"NONE",
	"PAP",
	"AUTO",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *APNAuthenticationEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_APNAuthenticationEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_APNAuthenticationEnumType, v)
	}
	*j = APNAuthenticationEnumType(v)
	return nil
}

// APN
// urn:x-oca:ocpp:uid:2:233134
// Collection of configuration data needed to make a data-connection over a
// cellular network.
//
// NOTE: When asking a GSM modem to dial in, it is possible to specify which mobile
// operator should be used. This can be done with the mobile country code (MCC) in
// combination with a mobile network code (MNC). Example: If your preferred network
// is Vodafone Netherlands, the MCC=204 and the MNC=04 which means the key
// PreferredNetwork = 20404 Some modems allows to specify a preferred network,
// which means, if this network is not available, a different network is used. If
// you specify UseOnlyPreferredNetwork and this network is not available, the modem
// will not dial in.
type APNType struct {
	// APN. APN. URI
	// urn:x-oca:ocpp:uid:1:568814
	// The Access Point Name as an URL.
	//
	Apn string `json:"apn" yaml:"apn" mapstructure:"apn"`

	// ApnAuthentication corresponds to the JSON schema field "apnAuthentication".
	ApnAuthentication APNAuthenticationEnumType `json:"apnAuthentication" yaml:"apnAuthentication" mapstructure:"apnAuthentication"`

	// APN. APN. Password
	// urn:x-oca:ocpp:uid:1:568819
	// APN Password.
	//
	ApnPassword *string `json:"apnPassword,omitempty" yaml:"apnPassword,omitempty" mapstructure:"apnPassword,omitempty"`

	// APN. APN. User_ Name
	// urn:x-oca:ocpp:uid:1:568818
	// APN username.
	//
	ApnUserName *string `json:"apnUserName,omitempty" yaml:"apnUserName,omitempty" mapstructure:"apnUserName,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// APN. Preferred_ Network. Mobile_ Network_ ID
	// urn:x-oca:ocpp:uid:1:568822
	// Preferred network, written as MCC and MNC concatenated. See note.
	//
	PreferredNetwork *string `json:"preferredNetwork,omitempty" yaml:"preferredNetwork,omitempty" mapstructure:"preferredNetwork,omitempty"`

	// APN. SIMPIN. PIN_ Code
	// urn:x-oca:ocpp:uid:1:568821
	// SIM card pin code.
	//
	SimPin *int `json:"simPin,omitempty" yaml:"simPin,omitempty" mapstructure:"simPin,omitempty"`

	// APN. Use_ Only_ Preferred_ Network. Indicator
	// urn:x-oca:ocpp:uid:1:568824
	// Default: false. Use only the preferred Network, do
	// not dial in when not available. See Note.
	//
	UseOnlyPreferredNetwork bool `json:"useOnlyPreferredNetwork,omitempty" yaml:"useOnlyPreferredNetwork,omitempty" mapstructure:"useOnlyPreferredNetwork,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *APNType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["apn"]; raw != nil && !ok {
		return fmt.Errorf("field apn in APNType: required")
	}
	if _, ok := raw["apnAuthentication"]; raw != nil && !ok {
		return fmt.Errorf("field apnAuthentication in APNType: required")
	}
	type Plain APNType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Apn) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "apn", 512)
	}
	if plain.ApnPassword != nil && len(*plain.ApnPassword) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "apnPassword", 20)
	}
	if plain.ApnUserName != nil && len(*plain.ApnUserName) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "apnUserName", 20)
	}
	if plain.PreferredNetwork != nil && len(*plain.PreferredNetwork) > 6 {
		return fmt.Errorf("field %s length: must be <= %d", "preferredNetwork", 6)
	}
	if v, ok := raw["useOnlyPreferredNetwork"]; !ok || v == nil {
		plain.UseOnlyPreferredNetwork = false
	}
	*j = APNType(plain)
	return nil
}

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId" mapstructure:"vendorId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["vendorId"]; raw != nil && !ok {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.VendorId) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "vendorId", 255)
	}
	*j = CustomDataType(plain)
	return nil
}

// Communication_ Function
// urn:x-oca:ocpp:uid:2:233304
// The NetworkConnectionProfile defines the functional and technical parameters of
// a communication link.
type NetworkConnectionProfileType struct {
	// Apn corresponds to the JSON schema field "apn".
	Apn *APNType `json:"apn,omitempty" yaml:"apn,omitempty" mapstructure:"apn,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Duration in seconds before a message send by the Charging Station via this
	// network connection times-out.
	// The best setting depends on the underlying network and response times of the
	// CSMS.
	// If you are looking for a some guideline: use 30 seconds as a starting point.
	//
	MessageTimeout int `json:"messageTimeout" yaml:"messageTimeout" mapstructure:"messageTimeout"`

	// Communication_ Function. OCPP_ Central_ System_ URL. URI
	// urn:x-oca:ocpp:uid:1:569357
	// URL of the CSMS(s) that this Charging Station  communicates with.
	//
	OcppCsmsUrl string `json:"ocppCsmsUrl" yaml:"ocppCsmsUrl" mapstructure:"ocppCsmsUrl"`

	// OcppInterface corresponds to the JSON schema field "ocppInterface".
	OcppInterface OCPPInterfaceEnumType `json:"ocppInterface" yaml:"ocppInterface" mapstructure:"ocppInterface"`

	// OcppTransport corresponds to the JSON schema field "ocppTransport".
	OcppTransport OCPPTransportEnumType `json:"ocppTransport" yaml:"ocppTransport" mapstructure:"ocppTransport"`

	// OcppVersion corresponds to the JSON schema field "ocppVersion".
	OcppVersion OCPPVersionEnumType `json:"ocppVersion" yaml:"ocppVersion" mapstructure:"ocppVersion"`

	// This field specifies the security profile used when connecting to the CSMS with
	// this NetworkConnectionProfile.
	//
	SecurityProfile int `json:"securityProfile" yaml:"securityProfile" mapstructure:"securityProfile"`

	// Vpn corresponds to the JSON schema field "vpn".
	Vpn *VPNType `json:"vpn,omitempty" yaml:"vpn,omitempty" mapstructure:"vpn,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NetworkConnectionProfileType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["messageTimeout"]; raw != nil && !ok {
		return fmt.Errorf("field messageTimeout in NetworkConnectionProfileType: required")
	}
	if _, ok := raw["ocppCsmsUrl"]; raw != nil && !ok {
		return fmt.Errorf("field ocppCsmsUrl in NetworkConnectionProfileType: required")
	}
	if _, ok := raw["ocppInterface"]; raw != nil && !ok {
		return fmt.Errorf("field ocppInterface in NetworkConnectionProfileType: required")
	}
	if _, ok := raw["ocppTransport"]; raw != nil && !ok {
		return fmt.Errorf("field ocppTransport in NetworkConnectionProfileType: required")
	}
	if _, ok := raw["ocppVersion"]; raw != nil && !ok {
		return fmt.Errorf("field ocppVersion in NetworkConnectionProfileType: required")
	}
	if _, ok := raw["securityProfile"]; raw != nil && !ok {
		return fmt.Errorf("field securityProfile in NetworkConnectionProfileType: required")
	}
	type Plain NetworkConnectionProfileType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.OcppCsmsUrl) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "ocppCsmsUrl", 512)
	}
	*j = NetworkConnectionProfileType(plain)
	return nil
}

type OCPPInterfaceEnumType string

const OCPPInterfaceEnumTypeWired0 OCPPInterfaceEnumType = "Wired0"
const OCPPInterfaceEnumTypeWired1 OCPPInterfaceEnumType = "Wired1"
const OCPPInterfaceEnumTypeWired2 OCPPInterfaceEnumType = "Wired2"
const OCPPInterfaceEnumTypeWired3 OCPPInterfaceEnumType = "Wired3"
const OCPPInterfaceEnumTypeWireless0 OCPPInterfaceEnumType = "Wireless0"
const OCPPInterfaceEnumTypeWireless1 OCPPInterfaceEnumType = "Wireless1"
const OCPPInterfaceEnumTypeWireless2 OCPPInterfaceEnumType = "Wireless2"
const OCPPInterfaceEnumTypeWireless3 OCPPInterfaceEnumType = "Wireless3"

var enumValues_OCPPInterfaceEnumType = []interface{}{
	"Wired0",
	"Wired1",
	"Wired2",
	"Wired3",
	"Wireless0",
	"Wireless1",
	"Wireless2",
	"Wireless3",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OCPPInterfaceEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OCPPInterfaceEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OCPPInterfaceEnumType, v)
	}
	*j = OCPPInterfaceEnumType(v)
	return nil
}

type OCPPTransportEnumType string

const OCPPTransportEnumTypeJSON OCPPTransportEnumType = "JSON"
const OCPPTransportEnumTypeSOAP OCPPTransportEnumType = "SOAP"

var enumValues_OCPPTransportEnumType = []interface{}{
	"JSON",
	"SOAP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OCPPTransportEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OCPPTransportEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OCPPTransportEnumType, v)
	}
	*j = OCPPTransportEnumType(v)
	return nil
}

type OCPPVersionEnumType string

const OCPPVersionEnumTypeOCPP12 OCPPVersionEnumType = "OCPP12"
const OCPPVersionEnumTypeOCPP15 OCPPVersionEnumType = "OCPP15"
const OCPPVersionEnumTypeOCPP16 OCPPVersionEnumType = "OCPP16"
const OCPPVersionEnumTypeOCPP20 OCPPVersionEnumType = "OCPP20"

var enumValues_OCPPVersionEnumType = []interface{}{
	"OCPP12",
	"OCPP15",
	"OCPP16",
	"OCPP20",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OCPPVersionEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OCPPVersionEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OCPPVersionEnumType, v)
	}
	*j = OCPPVersionEnumType(v)
	return nil
}

type SetNetworkProfileRequestJson struct {
	// Slot in which the configuration should be stored.
	//
	ConfigurationSlot int `json:"configurationSlot" yaml:"configurationSlot" mapstructure:"configurationSlot"`

	// ConnectionData corresponds to the JSON schema field "connectionData".
	ConnectionData NetworkConnectionProfileType `json:"connectionData" yaml:"connectionData" mapstructure:"connectionData"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetNetworkProfileRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["configurationSlot"]; raw != nil && !ok {
		return fmt.Errorf("field configurationSlot in SetNetworkProfileRequestJson: required")
	}
	if _, ok := raw["connectionData"]; raw != nil && !ok {
		return fmt.Errorf("field connectionData in SetNetworkProfileRequestJson: required")
	}
	type Plain SetNetworkProfileRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SetNetworkProfileRequestJson(plain)
	return nil
}

type VPNEnumType string

const VPNEnumTypeIKEv2 VPNEnumType = "IKEv2"
const VPNEnumTypeIPSec VPNEnumType = "IPSec"
const VPNEnumTypeL2TP VPNEnumType = "L2TP"
const VPNEnumTypePPTP VPNEnumType = "PPTP"

var enumValues_VPNEnumType = []interface{}{
	"IKEv2",
	"IPSec",
	"L2TP",
	"PPTP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VPNEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VPNEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VPNEnumType, v)
	}
	*j = VPNEnumType(v)
	return nil
}

// VPN
// urn:x-oca:ocpp:uid:2:233268
// VPN Configuration settings
type VPNType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// VPN. Group. Group_ Name
	// urn:x-oca:ocpp:uid:1:569274
	// VPN group.
	//
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// VPN. Key. VPN_ Key
	// urn:x-oca:ocpp:uid:1:569276
	// VPN shared secret.
	//
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// VPN. Password. Password
	// urn:x-oca:ocpp:uid:1:569275
	// VPN Password.
	//
	Password string `json:"password" yaml:"password" mapstructure:"password"`

	// VPN. Server. URI
	// urn:x-oca:ocpp:uid:1:569272
	// VPN Server Address
	//
	Server string `json:"server" yaml:"server" mapstructure:"server"`

	// Type corresponds to the JSON schema field "type".
	Type VPNEnumType `json:"type" yaml:"type" mapstructure:"type"`

	// VPN. User. User_ Name
	// urn:x-oca:ocpp:uid:1:569273
	// VPN User
	//
	User string `json:"user" yaml:"user" mapstructure:"user"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VPNType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in VPNType: required")
	}
	if _, ok := raw["password"]; raw != nil && !ok {
		return fmt.Errorf("field password in VPNType: required")
	}
	if _, ok := raw["server"]; raw != nil && !ok {
		return fmt.Errorf("field server in VPNType: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in VPNType: required")
	}
	if _, ok := raw["user"]; raw != nil && !ok {
		return fmt.Errorf("field user in VPNType: required")
	}
	type Plain VPNType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Group != nil && len(*plain.Group) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "group", 20)
	}
	if len(plain.Key) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "key", 255)
	}
	if len(plain.Password) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "password", 20)
	}
	if len(plain.Server) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "server", 512)
	}
	if len(plain.User) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "user", 20)
	}
	*j = VPNType(plain)
	return nil
}
