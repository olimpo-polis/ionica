// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package notifyDisplayMessagesRequest

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// A physical or logical component
type ComponentType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Evse corresponds to the JSON schema field "evse".
	Evse *EVSEType `json:"evse,omitempty" yaml:"evse,omitempty" mapstructure:"evse,omitempty"`

	// Name of instance in case the component exists as multiple instances. Case
	// Insensitive. strongly advised to use Camel Case.
	//
	Instance *string `json:"instance,omitempty" yaml:"instance,omitempty" mapstructure:"instance,omitempty"`

	// Name of the component. Name should be taken from the list of standardized
	// component names whenever possible. Case Insensitive. strongly advised to use
	// Camel Case.
	//
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ComponentType: required")
	}
	type Plain ComponentType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Instance != nil && len(*plain.Instance) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "instance", 50)
	}
	if len(plain.Name) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 50)
	}
	*j = ComponentType(plain)
	return nil
}

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId" mapstructure:"vendorId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["vendorId"]; raw != nil && !ok {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.VendorId) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "vendorId", 255)
	}
	*j = CustomDataType(plain)
	return nil
}

// EVSE
// urn:x-oca:ocpp:uid:2:233123
// Electric Vehicle Supply Equipment
type EVSEType struct {
	// An id to designate a specific connector (on an EVSE) by connector index number.
	//
	ConnectorId *int `json:"connectorId,omitempty" yaml:"connectorId,omitempty" mapstructure:"connectorId,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Identified_ Object. MRID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:569198
	// EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the
	// Charging Station.
	//
	Id int `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EVSEType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in EVSEType: required")
	}
	type Plain EVSEType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EVSEType(plain)
	return nil
}

// Message_ Content
// urn:x-enexis:ecdm:uid:2:234490
// Contains message details, for a message to be displayed on a Charging Station.
type MessageContentType struct {
	// Message_ Content. Content. Message
	// urn:x-enexis:ecdm:uid:1:570852
	// Message contents.
	//
	//
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format MessageFormatEnumType `json:"format" yaml:"format" mapstructure:"format"`

	// Message_ Content. Language. Language_ Code
	// urn:x-enexis:ecdm:uid:1:570849
	// Message language identifier. Contains a language code as defined in
	// &lt;&lt;ref-RFC5646,[RFC5646]&gt;&gt;.
	//
	Language *string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageContentType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["content"]; raw != nil && !ok {
		return fmt.Errorf("field content in MessageContentType: required")
	}
	if _, ok := raw["format"]; raw != nil && !ok {
		return fmt.Errorf("field format in MessageContentType: required")
	}
	type Plain MessageContentType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.Content) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "content", 512)
	}
	if plain.Language != nil && len(*plain.Language) > 8 {
		return fmt.Errorf("field %s length: must be <= %d", "language", 8)
	}
	*j = MessageContentType(plain)
	return nil
}

type MessageFormatEnumType string

const MessageFormatEnumTypeASCII MessageFormatEnumType = "ASCII"
const MessageFormatEnumTypeHTML MessageFormatEnumType = "HTML"
const MessageFormatEnumTypeURI MessageFormatEnumType = "URI"
const MessageFormatEnumTypeUTF8 MessageFormatEnumType = "UTF8"

var enumValues_MessageFormatEnumType = []interface{}{
	"ASCII",
	"HTML",
	"URI",
	"UTF8",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageFormatEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageFormatEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageFormatEnumType, v)
	}
	*j = MessageFormatEnumType(v)
	return nil
}

// Message_ Info
// urn:x-enexis:ecdm:uid:2:233264
// Contains message details, for a message to be displayed on a Charging Station.
type MessageInfoType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Display corresponds to the JSON schema field "display".
	Display *ComponentType `json:"display,omitempty" yaml:"display,omitempty" mapstructure:"display,omitempty"`

	// Message_ Info. End. Date_ Time
	// urn:x-enexis:ecdm:uid:1:569257
	// Until what date-time should this message be shown, after this date/time this
	// message SHALL be removed.
	//
	EndDateTime *time.Time `json:"endDateTime,omitempty" yaml:"endDateTime,omitempty" mapstructure:"endDateTime,omitempty"`

	// Identified_ Object. MRID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:569198
	// Master resource identifier, unique within an exchange context. It is defined
	// within the OCPP context as a positive Integer value (greater or equal to zero).
	//
	Id int `json:"id" yaml:"id" mapstructure:"id"`

	// Message corresponds to the JSON schema field "message".
	Message MessageContentType `json:"message" yaml:"message" mapstructure:"message"`

	// Priority corresponds to the JSON schema field "priority".
	Priority MessagePriorityEnumType `json:"priority" yaml:"priority" mapstructure:"priority"`

	// Message_ Info. Start. Date_ Time
	// urn:x-enexis:ecdm:uid:1:569256
	// From what date-time should this message be shown. If omitted: directly.
	//
	StartDateTime *time.Time `json:"startDateTime,omitempty" yaml:"startDateTime,omitempty" mapstructure:"startDateTime,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *MessageStateEnumType `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// During which transaction shall this message be shown.
	// Message SHALL be removed by the Charging Station after transaction has
	// ended.
	//
	TransactionId *string `json:"transactionId,omitempty" yaml:"transactionId,omitempty" mapstructure:"transactionId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageInfoType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in MessageInfoType: required")
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in MessageInfoType: required")
	}
	if _, ok := raw["priority"]; raw != nil && !ok {
		return fmt.Errorf("field priority in MessageInfoType: required")
	}
	type Plain MessageInfoType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TransactionId != nil && len(*plain.TransactionId) > 36 {
		return fmt.Errorf("field %s length: must be <= %d", "transactionId", 36)
	}
	*j = MessageInfoType(plain)
	return nil
}

type MessagePriorityEnumType string

const MessagePriorityEnumTypeAlwaysFront MessagePriorityEnumType = "AlwaysFront"
const MessagePriorityEnumTypeInFront MessagePriorityEnumType = "InFront"
const MessagePriorityEnumTypeNormalCycle MessagePriorityEnumType = "NormalCycle"

var enumValues_MessagePriorityEnumType = []interface{}{
	"AlwaysFront",
	"InFront",
	"NormalCycle",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessagePriorityEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessagePriorityEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessagePriorityEnumType, v)
	}
	*j = MessagePriorityEnumType(v)
	return nil
}

type MessageStateEnumType string

const MessageStateEnumTypeCharging MessageStateEnumType = "Charging"
const MessageStateEnumTypeFaulted MessageStateEnumType = "Faulted"
const MessageStateEnumTypeIdle MessageStateEnumType = "Idle"
const MessageStateEnumTypeUnavailable MessageStateEnumType = "Unavailable"

var enumValues_MessageStateEnumType = []interface{}{
	"Charging",
	"Faulted",
	"Idle",
	"Unavailable",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MessageStateEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MessageStateEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MessageStateEnumType, v)
	}
	*j = MessageStateEnumType(v)
	return nil
}

type NotifyDisplayMessagesRequestJson struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// MessageInfo corresponds to the JSON schema field "messageInfo".
	MessageInfo []MessageInfoType `json:"messageInfo,omitempty" yaml:"messageInfo,omitempty" mapstructure:"messageInfo,omitempty"`

	// The id of the
	// &lt;&lt;getdisplaymessagesrequest,GetDisplayMessagesRequest&gt;&gt; that
	// requested this message.
	//
	RequestId int `json:"requestId" yaml:"requestId" mapstructure:"requestId"`

	// "to be continued" indicator. Indicates whether another part of the report
	// follows in an upcoming NotifyDisplayMessagesRequest message. Default value when
	// omitted is false.
	//
	Tbc bool `json:"tbc,omitempty" yaml:"tbc,omitempty" mapstructure:"tbc,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotifyDisplayMessagesRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["requestId"]; raw != nil && !ok {
		return fmt.Errorf("field requestId in NotifyDisplayMessagesRequestJson: required")
	}
	type Plain NotifyDisplayMessagesRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MessageInfo != nil && len(plain.MessageInfo) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "messageInfo", 1)
	}
	if v, ok := raw["tbc"]; !ok || v == nil {
		plain.Tbc = false
	}
	*j = NotifyDisplayMessagesRequestJson(plain)
	return nil
}
