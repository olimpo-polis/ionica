// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package transactionEventRequest

import "encoding/json"
import "fmt"
import "reflect"
import "time"

// Contains a case insensitive identifier to use for the authorization and the type
// of authorization to support multiple forms of identifiers.
type AdditionalInfoType struct {
	// This field specifies the additional IdToken.
	//
	AdditionalIdToken string `json:"additionalIdToken" yaml:"additionalIdToken" mapstructure:"additionalIdToken"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// This defines the type of the additionalIdToken. This is a custom type, so the
	// implementation needs to be agreed upon by all involved parties.
	//
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AdditionalInfoType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["additionalIdToken"]; raw != nil && !ok {
		return fmt.Errorf("field additionalIdToken in AdditionalInfoType: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in AdditionalInfoType: required")
	}
	type Plain AdditionalInfoType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.AdditionalIdToken) > 36 {
		return fmt.Errorf("field %s length: must be <= %d", "additionalIdToken", 36)
	}
	if len(plain.Type) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "type", 50)
	}
	*j = AdditionalInfoType(plain)
	return nil
}

type ChargingStateEnumType string

const ChargingStateEnumTypeCharging ChargingStateEnumType = "Charging"
const ChargingStateEnumTypeEVConnected ChargingStateEnumType = "EVConnected"
const ChargingStateEnumTypeIdle ChargingStateEnumType = "Idle"
const ChargingStateEnumTypeSuspendedEV ChargingStateEnumType = "SuspendedEV"
const ChargingStateEnumTypeSuspendedEVSE ChargingStateEnumType = "SuspendedEVSE"

var enumValues_ChargingStateEnumType = []interface{}{
	"Charging",
	"EVConnected",
	"SuspendedEV",
	"SuspendedEVSE",
	"Idle",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChargingStateEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ChargingStateEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ChargingStateEnumType, v)
	}
	*j = ChargingStateEnumType(v)
	return nil
}

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId" mapstructure:"vendorId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["vendorId"]; raw != nil && !ok {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.VendorId) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "vendorId", 255)
	}
	*j = CustomDataType(plain)
	return nil
}

// EVSE
// urn:x-oca:ocpp:uid:2:233123
// Electric Vehicle Supply Equipment
type EVSEType struct {
	// An id to designate a specific connector (on an EVSE) by connector index number.
	//
	ConnectorId *int `json:"connectorId,omitempty" yaml:"connectorId,omitempty" mapstructure:"connectorId,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Identified_ Object. MRID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:569198
	// EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the
	// Charging Station.
	//
	Id int `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EVSEType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in EVSEType: required")
	}
	type Plain EVSEType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = EVSEType(plain)
	return nil
}

type IdTokenEnumType string

const IdTokenEnumTypeCentral IdTokenEnumType = "Central"
const IdTokenEnumTypeEMAID IdTokenEnumType = "eMAID"
const IdTokenEnumTypeISO14443 IdTokenEnumType = "ISO14443"
const IdTokenEnumTypeISO15693 IdTokenEnumType = "ISO15693"
const IdTokenEnumTypeKeyCode IdTokenEnumType = "KeyCode"
const IdTokenEnumTypeLocal IdTokenEnumType = "Local"
const IdTokenEnumTypeMacAddress IdTokenEnumType = "MacAddress"
const IdTokenEnumTypeNoAuthorization IdTokenEnumType = "NoAuthorization"

var enumValues_IdTokenEnumType = []interface{}{
	"Central",
	"eMAID",
	"ISO14443",
	"ISO15693",
	"KeyCode",
	"Local",
	"MacAddress",
	"NoAuthorization",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdTokenEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdTokenEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdTokenEnumType, v)
	}
	*j = IdTokenEnumType(v)
	return nil
}

// Contains a case insensitive identifier to use for the authorization and the type
// of authorization to support multiple forms of identifiers.
type IdTokenType struct {
	// AdditionalInfo corresponds to the JSON schema field "additionalInfo".
	AdditionalInfo []AdditionalInfoType `json:"additionalInfo,omitempty" yaml:"additionalInfo,omitempty" mapstructure:"additionalInfo,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// IdToken is case insensitive. Might hold the hidden id of an RFID tag, but can
	// for example also contain a UUID.
	//
	IdToken string `json:"idToken" yaml:"idToken" mapstructure:"idToken"`

	// Type corresponds to the JSON schema field "type".
	Type IdTokenEnumType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdTokenType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["idToken"]; raw != nil && !ok {
		return fmt.Errorf("field idToken in IdTokenType: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in IdTokenType: required")
	}
	type Plain IdTokenType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.AdditionalInfo != nil && len(plain.AdditionalInfo) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "additionalInfo", 1)
	}
	if len(plain.IdToken) > 36 {
		return fmt.Errorf("field %s length: must be <= %d", "idToken", 36)
	}
	*j = IdTokenType(plain)
	return nil
}

type LocationEnumType string

const LocationEnumTypeBody LocationEnumType = "Body"
const LocationEnumTypeCable LocationEnumType = "Cable"
const LocationEnumTypeEV LocationEnumType = "EV"
const LocationEnumTypeInlet LocationEnumType = "Inlet"
const LocationEnumTypeOutlet LocationEnumType = "Outlet"

var enumValues_LocationEnumType = []interface{}{
	"Body",
	"Cable",
	"EV",
	"Inlet",
	"Outlet",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocationEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LocationEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LocationEnumType, v)
	}
	*j = LocationEnumType(v)
	return nil
}

type MeasurandEnumType string

const MeasurandEnumTypeCurrentExport MeasurandEnumType = "Current.Export"
const MeasurandEnumTypeCurrentImport MeasurandEnumType = "Current.Import"
const MeasurandEnumTypeCurrentOffered MeasurandEnumType = "Current.Offered"
const MeasurandEnumTypeEnergyActiveExportInterval MeasurandEnumType = "Energy.Active.Export.Interval"
const MeasurandEnumTypeEnergyActiveExportRegister MeasurandEnumType = "Energy.Active.Export.Register"
const MeasurandEnumTypeEnergyActiveImportInterval MeasurandEnumType = "Energy.Active.Import.Interval"
const MeasurandEnumTypeEnergyActiveImportRegister MeasurandEnumType = "Energy.Active.Import.Register"
const MeasurandEnumTypeEnergyActiveNet MeasurandEnumType = "Energy.Active.Net"
const MeasurandEnumTypeEnergyApparentExport MeasurandEnumType = "Energy.Apparent.Export"
const MeasurandEnumTypeEnergyApparentImport MeasurandEnumType = "Energy.Apparent.Import"
const MeasurandEnumTypeEnergyApparentNet MeasurandEnumType = "Energy.Apparent.Net"
const MeasurandEnumTypeEnergyReactiveExportInterval MeasurandEnumType = "Energy.Reactive.Export.Interval"
const MeasurandEnumTypeEnergyReactiveExportRegister MeasurandEnumType = "Energy.Reactive.Export.Register"
const MeasurandEnumTypeEnergyReactiveImportInterval MeasurandEnumType = "Energy.Reactive.Import.Interval"
const MeasurandEnumTypeEnergyReactiveImportRegister MeasurandEnumType = "Energy.Reactive.Import.Register"
const MeasurandEnumTypeEnergyReactiveNet MeasurandEnumType = "Energy.Reactive.Net"
const MeasurandEnumTypeFrequency MeasurandEnumType = "Frequency"
const MeasurandEnumTypePowerActiveExport MeasurandEnumType = "Power.Active.Export"
const MeasurandEnumTypePowerActiveImport MeasurandEnumType = "Power.Active.Import"
const MeasurandEnumTypePowerFactor MeasurandEnumType = "Power.Factor"
const MeasurandEnumTypePowerOffered MeasurandEnumType = "Power.Offered"
const MeasurandEnumTypePowerReactiveExport MeasurandEnumType = "Power.Reactive.Export"
const MeasurandEnumTypePowerReactiveImport MeasurandEnumType = "Power.Reactive.Import"
const MeasurandEnumTypeSoC MeasurandEnumType = "SoC"
const MeasurandEnumTypeVoltage MeasurandEnumType = "Voltage"

var enumValues_MeasurandEnumType = []interface{}{
	"Current.Export",
	"Current.Import",
	"Current.Offered",
	"Energy.Active.Export.Register",
	"Energy.Active.Import.Register",
	"Energy.Reactive.Export.Register",
	"Energy.Reactive.Import.Register",
	"Energy.Active.Export.Interval",
	"Energy.Active.Import.Interval",
	"Energy.Active.Net",
	"Energy.Reactive.Export.Interval",
	"Energy.Reactive.Import.Interval",
	"Energy.Reactive.Net",
	"Energy.Apparent.Net",
	"Energy.Apparent.Import",
	"Energy.Apparent.Export",
	"Frequency",
	"Power.Active.Export",
	"Power.Active.Import",
	"Power.Factor",
	"Power.Offered",
	"Power.Reactive.Export",
	"Power.Reactive.Import",
	"SoC",
	"Voltage",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeasurandEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MeasurandEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MeasurandEnumType, v)
	}
	*j = MeasurandEnumType(v)
	return nil
}

// Meter_ Value
// urn:x-oca:ocpp:uid:2:233265
// Collection of one or more sampled values in MeterValuesRequest and
// TransactionEvent. All sampled values in a MeterValue are sampled at the same
// point in time.
type MeterValueType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// SampledValue corresponds to the JSON schema field "sampledValue".
	SampledValue []SampledValueType `json:"sampledValue" yaml:"sampledValue" mapstructure:"sampledValue"`

	// Meter_ Value. Timestamp. Date_ Time
	// urn:x-oca:ocpp:uid:1:569259
	// Timestamp for measured value(s).
	//
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MeterValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["sampledValue"]; raw != nil && !ok {
		return fmt.Errorf("field sampledValue in MeterValueType: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in MeterValueType: required")
	}
	type Plain MeterValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.SampledValue != nil && len(plain.SampledValue) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "sampledValue", 1)
	}
	*j = MeterValueType(plain)
	return nil
}

type PhaseEnumType string

const PhaseEnumTypeL1 PhaseEnumType = "L1"
const PhaseEnumTypeL1L2 PhaseEnumType = "L1-L2"
const PhaseEnumTypeL1N PhaseEnumType = "L1-N"
const PhaseEnumTypeL2 PhaseEnumType = "L2"
const PhaseEnumTypeL2L3 PhaseEnumType = "L2-L3"
const PhaseEnumTypeL2N PhaseEnumType = "L2-N"
const PhaseEnumTypeL3 PhaseEnumType = "L3"
const PhaseEnumTypeL3L1 PhaseEnumType = "L3-L1"
const PhaseEnumTypeL3N PhaseEnumType = "L3-N"
const PhaseEnumTypeN PhaseEnumType = "N"

var enumValues_PhaseEnumType = []interface{}{
	"L1",
	"L2",
	"L3",
	"N",
	"L1-N",
	"L2-N",
	"L3-N",
	"L1-L2",
	"L2-L3",
	"L3-L1",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PhaseEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PhaseEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PhaseEnumType, v)
	}
	*j = PhaseEnumType(v)
	return nil
}

type ReadingContextEnumType string

const ReadingContextEnumTypeInterruptionBegin ReadingContextEnumType = "Interruption.Begin"
const ReadingContextEnumTypeInterruptionEnd ReadingContextEnumType = "Interruption.End"
const ReadingContextEnumTypeOther ReadingContextEnumType = "Other"
const ReadingContextEnumTypeSampleClock ReadingContextEnumType = "Sample.Clock"
const ReadingContextEnumTypeSamplePeriodic ReadingContextEnumType = "Sample.Periodic"
const ReadingContextEnumTypeTransactionBegin ReadingContextEnumType = "Transaction.Begin"
const ReadingContextEnumTypeTransactionEnd ReadingContextEnumType = "Transaction.End"
const ReadingContextEnumTypeTrigger ReadingContextEnumType = "Trigger"

var enumValues_ReadingContextEnumType = []interface{}{
	"Interruption.Begin",
	"Interruption.End",
	"Other",
	"Sample.Clock",
	"Sample.Periodic",
	"Transaction.Begin",
	"Transaction.End",
	"Trigger",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReadingContextEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReadingContextEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReadingContextEnumType, v)
	}
	*j = ReadingContextEnumType(v)
	return nil
}

type ReasonEnumType string

const ReasonEnumTypeDeAuthorized ReasonEnumType = "DeAuthorized"
const ReasonEnumTypeEVDisconnected ReasonEnumType = "EVDisconnected"
const ReasonEnumTypeEmergencyStop ReasonEnumType = "EmergencyStop"
const ReasonEnumTypeEnergyLimitReached ReasonEnumType = "EnergyLimitReached"
const ReasonEnumTypeGroundFault ReasonEnumType = "GroundFault"
const ReasonEnumTypeImmediateReset ReasonEnumType = "ImmediateReset"
const ReasonEnumTypeLocal ReasonEnumType = "Local"
const ReasonEnumTypeLocalOutOfCredit ReasonEnumType = "LocalOutOfCredit"
const ReasonEnumTypeMasterPass ReasonEnumType = "MasterPass"
const ReasonEnumTypeOther ReasonEnumType = "Other"
const ReasonEnumTypeOvercurrentFault ReasonEnumType = "OvercurrentFault"
const ReasonEnumTypePowerLoss ReasonEnumType = "PowerLoss"
const ReasonEnumTypePowerQuality ReasonEnumType = "PowerQuality"
const ReasonEnumTypeReboot ReasonEnumType = "Reboot"
const ReasonEnumTypeRemote ReasonEnumType = "Remote"
const ReasonEnumTypeSOCLimitReached ReasonEnumType = "SOCLimitReached"
const ReasonEnumTypeStoppedByEV ReasonEnumType = "StoppedByEV"
const ReasonEnumTypeTimeLimitReached ReasonEnumType = "TimeLimitReached"
const ReasonEnumTypeTimeout ReasonEnumType = "Timeout"

var enumValues_ReasonEnumType = []interface{}{
	"DeAuthorized",
	"EmergencyStop",
	"EnergyLimitReached",
	"EVDisconnected",
	"GroundFault",
	"ImmediateReset",
	"Local",
	"LocalOutOfCredit",
	"MasterPass",
	"Other",
	"OvercurrentFault",
	"PowerLoss",
	"PowerQuality",
	"Reboot",
	"Remote",
	"SOCLimitReached",
	"StoppedByEV",
	"TimeLimitReached",
	"Timeout",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReasonEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReasonEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReasonEnumType, v)
	}
	*j = ReasonEnumType(v)
	return nil
}

// Sampled_ Value
// urn:x-oca:ocpp:uid:2:233266
// Single sampled value in MeterValues. Each value can be accompanied by optional
// fields.
//
// To save on mobile data usage, default values of all of the optional fields are
// such that. The value without any additional fields will be interpreted, as a
// register reading of active import energy in Wh (Watt-hour) units.
type SampledValueType struct {
	// Context corresponds to the JSON schema field "context".
	Context *ReadingContextEnumType `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Location corresponds to the JSON schema field "location".
	Location *LocationEnumType `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Measurand corresponds to the JSON schema field "measurand".
	Measurand *MeasurandEnumType `json:"measurand,omitempty" yaml:"measurand,omitempty" mapstructure:"measurand,omitempty"`

	// Phase corresponds to the JSON schema field "phase".
	Phase *PhaseEnumType `json:"phase,omitempty" yaml:"phase,omitempty" mapstructure:"phase,omitempty"`

	// SignedMeterValue corresponds to the JSON schema field "signedMeterValue".
	SignedMeterValue *SignedMeterValueType `json:"signedMeterValue,omitempty" yaml:"signedMeterValue,omitempty" mapstructure:"signedMeterValue,omitempty"`

	// UnitOfMeasure corresponds to the JSON schema field "unitOfMeasure".
	UnitOfMeasure *UnitOfMeasureType `json:"unitOfMeasure,omitempty" yaml:"unitOfMeasure,omitempty" mapstructure:"unitOfMeasure,omitempty"`

	// Sampled_ Value. Value. Measure
	// urn:x-oca:ocpp:uid:1:569260
	// Indicates the measured value.
	//
	//
	Value float64 `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SampledValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["value"]; raw != nil && !ok {
		return fmt.Errorf("field value in SampledValueType: required")
	}
	type Plain SampledValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SampledValueType(plain)
	return nil
}

// Represent a signed version of the meter value.
type SignedMeterValueType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Method used to encode the meter values before applying the digital signature
	// algorithm.
	//
	EncodingMethod string `json:"encodingMethod" yaml:"encodingMethod" mapstructure:"encodingMethod"`

	// Base64 encoded, sending depends on configuration variable
	// _PublicKeyWithSignedMeterValue_.
	//
	PublicKey string `json:"publicKey" yaml:"publicKey" mapstructure:"publicKey"`

	// Base64 encoded, contains the signed data which might contain more then just the
	// meter value. It can contain information like timestamps, reference to a
	// customer etc.
	//
	SignedMeterData string `json:"signedMeterData" yaml:"signedMeterData" mapstructure:"signedMeterData"`

	// Method used to create the digital signature.
	//
	SigningMethod string `json:"signingMethod" yaml:"signingMethod" mapstructure:"signingMethod"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SignedMeterValueType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["encodingMethod"]; raw != nil && !ok {
		return fmt.Errorf("field encodingMethod in SignedMeterValueType: required")
	}
	if _, ok := raw["publicKey"]; raw != nil && !ok {
		return fmt.Errorf("field publicKey in SignedMeterValueType: required")
	}
	if _, ok := raw["signedMeterData"]; raw != nil && !ok {
		return fmt.Errorf("field signedMeterData in SignedMeterValueType: required")
	}
	if _, ok := raw["signingMethod"]; raw != nil && !ok {
		return fmt.Errorf("field signingMethod in SignedMeterValueType: required")
	}
	type Plain SignedMeterValueType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.EncodingMethod) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "encodingMethod", 50)
	}
	if len(plain.PublicKey) > 2500 {
		return fmt.Errorf("field %s length: must be <= %d", "publicKey", 2500)
	}
	if len(plain.SignedMeterData) > 2500 {
		return fmt.Errorf("field %s length: must be <= %d", "signedMeterData", 2500)
	}
	if len(plain.SigningMethod) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "signingMethod", 50)
	}
	*j = SignedMeterValueType(plain)
	return nil
}

type TransactionEventEnumType string

const TransactionEventEnumTypeEnded TransactionEventEnumType = "Ended"
const TransactionEventEnumTypeStarted TransactionEventEnumType = "Started"
const TransactionEventEnumTypeUpdated TransactionEventEnumType = "Updated"

var enumValues_TransactionEventEnumType = []interface{}{
	"Ended",
	"Started",
	"Updated",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionEventEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransactionEventEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransactionEventEnumType, v)
	}
	*j = TransactionEventEnumType(v)
	return nil
}

type TransactionEventRequestJson struct {
	// The maximum current of the connected cable in Ampere (A).
	//
	CableMaxCurrent *int `json:"cableMaxCurrent,omitempty" yaml:"cableMaxCurrent,omitempty" mapstructure:"cableMaxCurrent,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// EventType corresponds to the JSON schema field "eventType".
	EventType TransactionEventEnumType `json:"eventType" yaml:"eventType" mapstructure:"eventType"`

	// Evse corresponds to the JSON schema field "evse".
	Evse *EVSEType `json:"evse,omitempty" yaml:"evse,omitempty" mapstructure:"evse,omitempty"`

	// IdToken corresponds to the JSON schema field "idToken".
	IdToken *IdTokenType `json:"idToken,omitempty" yaml:"idToken,omitempty" mapstructure:"idToken,omitempty"`

	// MeterValue corresponds to the JSON schema field "meterValue".
	MeterValue []MeterValueType `json:"meterValue,omitempty" yaml:"meterValue,omitempty" mapstructure:"meterValue,omitempty"`

	// If the Charging Station is able to report the number of phases used, then it
	// SHALL provide it. When omitted the CSMS may be able to determine the number of
	// phases used via device management.
	//
	NumberOfPhasesUsed *int `json:"numberOfPhasesUsed,omitempty" yaml:"numberOfPhasesUsed,omitempty" mapstructure:"numberOfPhasesUsed,omitempty"`

	// Indication that this transaction event happened when the Charging Station was
	// offline. Default = false, meaning: the event occurred when the Charging Station
	// was online.
	//
	Offline bool `json:"offline,omitempty" yaml:"offline,omitempty" mapstructure:"offline,omitempty"`

	// This contains the Id of the reservation that terminates as a result of this
	// transaction.
	//
	ReservationId *int `json:"reservationId,omitempty" yaml:"reservationId,omitempty" mapstructure:"reservationId,omitempty"`

	// Incremental sequence number, helps with determining if all messages of a
	// transaction have been received.
	//
	SeqNo int `json:"seqNo" yaml:"seqNo" mapstructure:"seqNo"`

	// The date and time at which this transaction event occurred.
	//
	Timestamp time.Time `json:"timestamp" yaml:"timestamp" mapstructure:"timestamp"`

	// TransactionInfo corresponds to the JSON schema field "transactionInfo".
	TransactionInfo TransactionType `json:"transactionInfo" yaml:"transactionInfo" mapstructure:"transactionInfo"`

	// TriggerReason corresponds to the JSON schema field "triggerReason".
	TriggerReason TriggerReasonEnumType `json:"triggerReason" yaml:"triggerReason" mapstructure:"triggerReason"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionEventRequestJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["eventType"]; raw != nil && !ok {
		return fmt.Errorf("field eventType in TransactionEventRequestJson: required")
	}
	if _, ok := raw["seqNo"]; raw != nil && !ok {
		return fmt.Errorf("field seqNo in TransactionEventRequestJson: required")
	}
	if _, ok := raw["timestamp"]; raw != nil && !ok {
		return fmt.Errorf("field timestamp in TransactionEventRequestJson: required")
	}
	if _, ok := raw["transactionInfo"]; raw != nil && !ok {
		return fmt.Errorf("field transactionInfo in TransactionEventRequestJson: required")
	}
	if _, ok := raw["triggerReason"]; raw != nil && !ok {
		return fmt.Errorf("field triggerReason in TransactionEventRequestJson: required")
	}
	type Plain TransactionEventRequestJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MeterValue != nil && len(plain.MeterValue) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "meterValue", 1)
	}
	if v, ok := raw["offline"]; !ok || v == nil {
		plain.Offline = false
	}
	*j = TransactionEventRequestJson(plain)
	return nil
}

// Transaction
// urn:x-oca:ocpp:uid:2:233318
type TransactionType struct {
	// ChargingState corresponds to the JSON schema field "chargingState".
	ChargingState *ChargingStateEnumType `json:"chargingState,omitempty" yaml:"chargingState,omitempty" mapstructure:"chargingState,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// The ID given to remote start request (&lt;&lt;requeststarttransactionrequest,
	// RequestStartTransactionRequest&gt;&gt;. This enables to CSMS to match the
	// started transaction to the given start request.
	//
	RemoteStartId *int `json:"remoteStartId,omitempty" yaml:"remoteStartId,omitempty" mapstructure:"remoteStartId,omitempty"`

	// StoppedReason corresponds to the JSON schema field "stoppedReason".
	StoppedReason *ReasonEnumType `json:"stoppedReason,omitempty" yaml:"stoppedReason,omitempty" mapstructure:"stoppedReason,omitempty"`

	// Transaction. Time_ Spent_ Charging. Elapsed_ Time
	// urn:x-oca:ocpp:uid:1:569415
	// Contains the total time that energy flowed from EVSE to EV during the
	// transaction (in seconds). Note that timeSpentCharging is smaller or equal to
	// the duration of the transaction.
	//
	TimeSpentCharging *int `json:"timeSpentCharging,omitempty" yaml:"timeSpentCharging,omitempty" mapstructure:"timeSpentCharging,omitempty"`

	// This contains the Id of the transaction.
	//
	TransactionId string `json:"transactionId" yaml:"transactionId" mapstructure:"transactionId"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["transactionId"]; raw != nil && !ok {
		return fmt.Errorf("field transactionId in TransactionType: required")
	}
	type Plain TransactionType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if len(plain.TransactionId) > 36 {
		return fmt.Errorf("field %s length: must be <= %d", "transactionId", 36)
	}
	*j = TransactionType(plain)
	return nil
}

type TriggerReasonEnumType string

const TriggerReasonEnumTypeAbnormalCondition TriggerReasonEnumType = "AbnormalCondition"
const TriggerReasonEnumTypeAuthorized TriggerReasonEnumType = "Authorized"
const TriggerReasonEnumTypeCablePluggedIn TriggerReasonEnumType = "CablePluggedIn"
const TriggerReasonEnumTypeChargingRateChanged TriggerReasonEnumType = "ChargingRateChanged"
const TriggerReasonEnumTypeChargingStateChanged TriggerReasonEnumType = "ChargingStateChanged"
const TriggerReasonEnumTypeDeauthorized TriggerReasonEnumType = "Deauthorized"
const TriggerReasonEnumTypeEVCommunicationLost TriggerReasonEnumType = "EVCommunicationLost"
const TriggerReasonEnumTypeEVConnectTimeout TriggerReasonEnumType = "EVConnectTimeout"
const TriggerReasonEnumTypeEVDeparted TriggerReasonEnumType = "EVDeparted"
const TriggerReasonEnumTypeEVDetected TriggerReasonEnumType = "EVDetected"
const TriggerReasonEnumTypeEnergyLimitReached TriggerReasonEnumType = "EnergyLimitReached"
const TriggerReasonEnumTypeMeterValueClock TriggerReasonEnumType = "MeterValueClock"
const TriggerReasonEnumTypeMeterValuePeriodic TriggerReasonEnumType = "MeterValuePeriodic"
const TriggerReasonEnumTypeRemoteStart TriggerReasonEnumType = "RemoteStart"
const TriggerReasonEnumTypeRemoteStop TriggerReasonEnumType = "RemoteStop"
const TriggerReasonEnumTypeResetCommand TriggerReasonEnumType = "ResetCommand"
const TriggerReasonEnumTypeSignedDataReceived TriggerReasonEnumType = "SignedDataReceived"
const TriggerReasonEnumTypeStopAuthorized TriggerReasonEnumType = "StopAuthorized"
const TriggerReasonEnumTypeTimeLimitReached TriggerReasonEnumType = "TimeLimitReached"
const TriggerReasonEnumTypeTrigger TriggerReasonEnumType = "Trigger"
const TriggerReasonEnumTypeUnlockCommand TriggerReasonEnumType = "UnlockCommand"

var enumValues_TriggerReasonEnumType = []interface{}{
	"Authorized",
	"CablePluggedIn",
	"ChargingRateChanged",
	"ChargingStateChanged",
	"Deauthorized",
	"EnergyLimitReached",
	"EVCommunicationLost",
	"EVConnectTimeout",
	"MeterValueClock",
	"MeterValuePeriodic",
	"TimeLimitReached",
	"Trigger",
	"UnlockCommand",
	"StopAuthorized",
	"EVDeparted",
	"EVDetected",
	"RemoteStop",
	"RemoteStart",
	"AbnormalCondition",
	"SignedDataReceived",
	"ResetCommand",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TriggerReasonEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TriggerReasonEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TriggerReasonEnumType, v)
	}
	*j = TriggerReasonEnumType(v)
	return nil
}

// Represents a UnitOfMeasure with a multiplier
type UnitOfMeasureType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty" mapstructure:"customData,omitempty"`

	// Multiplier, this value represents the exponent to base 10. I.e. multiplier 3
	// means 10 raised to the 3rd power. Default is 0.
	//
	Multiplier int `json:"multiplier,omitempty" yaml:"multiplier,omitempty" mapstructure:"multiplier,omitempty"`

	// Unit of the value. Default = "Wh" if the (default) measurand is an "Energy"
	// type.
	// This field SHALL use a value from the list Standardized Units of Measurements
	// in Part 2 Appendices.
	// If an applicable unit is available in that list, otherwise a "custom" unit
	// might be used.
	//
	Unit string `json:"unit,omitempty" yaml:"unit,omitempty" mapstructure:"unit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnitOfMeasureType) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain UnitOfMeasureType
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["multiplier"]; !ok || v == nil {
		plain.Multiplier = 0.0
	}
	if v, ok := raw["unit"]; !ok || v == nil {
		plain.Unit = "Wh"
	}
	if len(plain.Unit) > 20 {
		return fmt.Errorf("field %s length: must be <= %d", "unit", 20)
	}
	*j = UnitOfMeasureType(plain)
	return nil
}
